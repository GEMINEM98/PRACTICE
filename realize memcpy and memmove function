//模拟实现memcpy（任意类型拷贝）
//发生内存重叠时，不保证结果正确
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>

void* my_memcpy(void* dest, const void* src, size_t sz)
{
	assert(dest&&src);
	char* dest_ = (char*)dest;
	char* src_ = (const char*)src;
	for (size_t i = 0; i < sz; ++i)
	{
		dest_[i] = src_[i];
	}
	return dest;
}

int main() 
{
	int dest[10] = { 0,1,2,3,4,5 };
	int src[] = { 8,8,8 };
	my_memcpy(dest, src, sizeof(src));
	for (int i = 0; i < 10; ++i)
	{
		printf("%d ", dest[i]);
	}
	printf("\n");
	system("pause");
	return 0;
}



//模拟实现memmove(拷贝)
//发生内存重叠时，保证正确性
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<assert.h>
#include<stdlib.h>

void* my_memmove(void* dest, const void* src, size_t size)
{
	assert(dest&&src);
	char* dest_ = (char*)dest;
	const char* src_ = (const char*)src;
	if ((dest_ > src_)&&(dest_ < src_ + size))
	{
		for (size_t i = size - 1; i >= 0; --i)//从后往前拷
		{
			dest_[i] = src_[i];
		}
	}
	else
	{
		for (size_t j = 0; j < size; ++j)//从前往后拷
		{
			dest_[j] = src_[j];
		}
	}
	return dest;
}

int main()
{
	int dest[10] = { 0,1,2,3,4,5,6,7,8,9 };
	//int src[] = { 9,9 };
	//my_memmove(dest, src, sizeof(src));         1.把src中的所有拷贝到dest中（两个数组，不存在内存重叠问题）
	my_memmove(dest, dest+3, 2*sizeof(int));//    2.把dest中的3和4拷贝到dest中（一个数组，存在内存重叠问题）
	for (size_t i = 0; i < 10; ++i)            // dest+3  :  从下标为(0+3)处开始拷贝
	{                                          // 2*sizeof(int)  :  拷贝2*4个字节，就是两个int元素 3和4
		printf("%d ", dest[i]);
	}
	printf("\n");
	system("pause");
	return 0;
}
